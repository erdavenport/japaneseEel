#!/usr/bin/env Rscript

######  
suppressMessages(library("docopt"))
"
Usage:
	create_individual_distance_matrix.R --raw_file=<raw_file> --cores=<cores> --outpath=<outpath>

Description: This script will create a distance matrix for each pair of individuals based off of shared SNPs. Goes through each pair of individuals and compares the SNPs that are called in each individual. If a SNP is the same 0, if one difference, 1, if 2 differences 2. Sum up distance and divide by 2 * the number of shared SNPs. Create a distance matrix from all of those pairs. Also output the number of SNPs shared between each pair. 

Options:
	--raw_file=<raw_file>		ped file 
	--cores=<cores>				number of cores to use
	--outpath=<outpath>			path of where to save output
" -> doc
######

###### PARAMETERS ##########
# Set the parameters:
today <- Sys.Date()											# Set the date that will go on the end of the files generated by this script
today <- format(today, format="%m%d%y")
#############################



##### Load arguments:
opts <- docopt(doc)
raw_file <- opts$raw_file
cores <- opts$cores
outpath <- opts$outpath

# raw_file <- "../data/STACKS_processed/7_depth_optimization/m3/rxstacks_corrected/coverage_filtered/batch_2.plink.raw"
# cores <- 2
# outpath <- "../results/6_Fst/m3/"


##### Load libraries:
library(parallel)



##### Read in data:
print("reading in data")
raw <- read.table(raw_file, sep=" ", header=TRUE, stringsAsFactors=FALSE, colClasses="character", nrows=60)



##### Function to calculate distance:
calcMyDist <- function(x) {
	A <- raw[x[1], 7:dim(raw)[2]]
	B <- raw[x[2], 7:dim(raw)[2]]
	
	# If they share both variants,	 C == 0
	# If they share one variant,  	 C == 1
	# If they share neither variant, C == 2
	C <- abs(as.numeric(A) - as.numeric(B))
	
	# Remove any SNPs where someone has a missing value
	C2 <- C[-which(is.na(C))] 
	
	# Calculate distance
	distance <- sum(C2)/(2*length(C2))
	nSNPs <- length(C2)
	
	# Return vector:
	returnme <- c(raw$IID[x], nSNPs, distance)
	return(returnme)
}



##### Apply function over all individuals in parallel:	
print("calculating distances in parallel")

# Matrix of all pairs of individuals
combos <- t(combn(1:nrow(raw), 2))
#combos <- t(combn(1:5,2)) # For testing only

# Start time:
strt <- Sys.time()

# Convert to list format for mclapply (each row an element of list):
xy.list <- split(combos, seq(nrow(combos)))

# Apply function to each element of the list:
dist.out <- mclapply(xy.list, calcMyDist, mc.cores=cores)

# Print out run time to screen:
print(Sys.time() - strt)

# Concatenate distance out into a matrix
dists <- do.call(rbind, dist.out)



##### Save distance file:
write.table(dists, paste0(outpath, "table_pairwise_individual_genetic_distances.txt"), sep="\t", row.names=FALSE, quote=FALSE)

print("DONE!")
