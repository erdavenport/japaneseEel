#!/usr/bin/env Rscript

######  
suppressMessages(library("docopt"))
"
Usage:
	stats_in_paper.R 
	
Description: This script will calculate and output all stats reported in the manuscript of the paper. 

Options:
" -> doc
######

###### PARAMETERS ##########
# Set the parameters:
today <- Sys.Date()											# Set the date that will go on the end of the files generated by this script
today <- format(today, format="%m%d%y")
#############################

# Initialize df of things to report
stuff <- data.frame(item = NA, value = NA)

# Calculate total loci identified pre-filtering:
loci <- system("wc -l data/STACKS_processed/4_depth_optimization/m3/batch_1.catalog.tags.tsv", intern = TRUE) 
myloci <- strsplit(loci, split = " ")[[1]][1]
stuff[1, ] <- c("total loci called m3 pre-filtering", myloci)

# Calculate total loci identified post-filtering:
loci <- system("wc -l data/STACKS_processed/4_depth_optimization/m3/rxstacks_corrected/coverage_filtered/batch_1.vcf", intern = TRUE)
myloci <- as.numeric(strsplit(loci, split = " ")[[1]][1]) - 11
stuff <- rbind(stuff, c("loci retained after filtering m3", myloci))

# Get number of reads mapping to nuclear genome:
bowtie_file <- "results/2_processing_info/table_alignment_stats_bowtie_nuclear_120718ERD.txt"
bowtie <- read.table(bowtie_file, sep = "\t", header = TRUE)
aligned <- mean(bowtie$reads_aligned)
stuff <- rbind(stuff, c("average reads mapping to nuclear reference genome", aligned))

# Reads mapping to JJ-107:
ind <- which(rownames(bowtie) == "JJ-107")
stuff <- rbind(stuff, c("reads mapping to nuclear genome for JJ-107", bowtie$reads_aligned[ind]))

# Reads mapping to mitochondrial genome:
bowtie_file_mito <- "results/2_processing_info/table_alignment_stats_bowtie_mtDNA_120718ERD.txt"
bowtie_mito <- read.table(bowtie_file_mito, sep = "\t", header = TRUE)
mito_aligned <- mean(bowtie_mito$reads_aligned)
stuff <- rbind(stuff, c("average reads mapping to mito genome", mito_aligned))

# Total reads generated in the experiment:
lib1 <- system('grep "Total Sequences" /fs/cbsufsrv5/data2/japaneseEel/data/STACKS_processed/0_process_radtags_out/process_radtags.fastq_files_updated.log', intern = TRUE)
lib1_size <- as.numeric(strsplit(lib1, "\t")[[1]][2])

lib2 <- system('grep "Total Sequences" /fs/cbsufsrv5/data2/japaneseEel/data/STACKS_processed/0_process_radtags_out_32_36_manli2/process_radtags.fastq_files_updated.log', intern = TRUE)
lib2_size <- as.numeric(strsplit(lib2, "\t")[[1]][2])

total_reads <- lib1_size + lib2_size
stuff <- rbind(stuff, c("total number of reads generated", total_reads))

# Reads retained after process_radtags:
ret1 <- system('grep "Retained Reads" /fs/cbsufsrv5/data2/japaneseEel/data/STACKS_processed/0_process_radtags_out/process_radtags.fastq_files_updated.log', intern = TRUE)[2]
ret1_size <- as.numeric(strsplit(ret1, "\t")[[1]][2])

ret2 <- system('grep "Retained Reads" /fs/cbsufsrv5/data2/japaneseEel/data/STACKS_processed/0_process_radtags_out_32_36_manli2/process_radtags.fastq_files_updated.log', intern = TRUE)[2]
ret2_size <- as.numeric(strsplit(ret2, "\t")[[1]][2])

retained_reads <- ret1_size + ret2_size
stuff <- rbind(stuff, c("total number of retained reads", retained_reads))

# Calculate percent of retained reads from total:
stuff <- rbind(stuff, c("What % of total seqed reads were retained", retained_reads/total_reads))

# Calculate number of discarded reads:
stuff <- rbind(stuff, c("Number of discarded reads", total_reads - retained_reads))

# Percent of total reads that were discarde
stuff <- rbind(stuff, c("% of total seqed reads discarded", (total_reads - retained_reads)/total_reads))

# Reads aligning to nuclear genome:
mapped_nuc <- sum(bowtie$reads_aligned)
stuff <- rbind(stuff, c("total number of reads mapped to nuclear genome", mapped_nuc))

# Percentage of retained reads that mapped to nuclear genome:
mapped_nuc_perc <- mapped_nuc/retained_reads
stuff <- rbind(stuff, c("percentage of retained reads mapped to nuclear genome", mapped_nuc_perc))

# Total number of reads failing to align to nuclear genome:
failed_nuc_align <- sum(bowtie$reads_failing_alignment)
stuff <- rbind(stuff, c("number of reads failing alignment to nuclear genome", failed_nuc_align))

# Percentage of reads that failed to align to nuclear genome:
stuff <- rbind(stuff, c("% of retained reads that failed alignment to nuclear genome", failed_nuc_align/retained_reads))

# Number of reads with ambiguous mapping:
amb_map <- sum(bowtie$reads_ambiguous_alignment)
stuff <- rbind(stuff, c("reads with ambiguous alignment", amb_map))

# Percentage of reads with ambiguous maping:
stuff <- rbind(stuff, c("% of retained reads with ambiguous alignment", amb_map/retained_reads))

# Total percentage of reads discarded:
stuff <- rbind(stuff, c("total percentage of raw reads discarded", (total_reads - mapped_nuc)/total_reads))

# Number of SNPs in the final catalogs for m3, m6, m10:
m3_vcf_size <- system("wc -l data/STACKS_processed/4_depth_optimization/m3/rxstacks_corrected/coverage_filtered/batch_1.vcf", intern = TRUE)
m3_cat_size <- as.numeric(strsplit(m3_vcf_size, split = " ")[[1]][1]) - 11
stuff <- rbind(stuff, c("loci in catalog -m 3", m3_cat_size))

m6_vcf_size <- system("wc -l data/STACKS_processed/4_depth_optimization/m6/rxstacks_corrected/coverage_filtered/batch_3.vcf", intern = TRUE)
m6_cat_size <- as.numeric(strsplit(m6_vcf_size, split = " ")[[1]][1]) - 11
stuff <- rbind(stuff, c("loci in catalog -m 6", m6_cat_size))

m10_vcf_size <- system("wc -l data/STACKS_processed/4_depth_optimization/m10/rxstacks_corrected/coverage_filtered/batch_4.vcf", intern = TRUE)
m10_cat_size <- as.numeric(strsplit(m10_vcf_size, split = " ")[[1]][1]) - 11
stuff <- rbind(stuff, c("loci in catalog -m 10", m10_cat_size))

# Number of SNPs called for m3 initially by STACKS:
m3_SNPs <- system("wc -l data/STACKS_processed/4_depth_optimization/m3/batch_1.catalog.snps.tsv", intern = TRUE)
m3_SNPs <- as.numeric(strsplit(m3_SNPs, split = " ")[[1]][1])
stuff <- rbind(stuff, c("SNPs in catalog -m 3 initially", m3_SNPs))

# Number of SNPs retained after corrections module:
m3_rx_SNPs <- system("wc -l data/STACKS_processed/4_depth_optimization/m3/rxstacks_corrected/batch_1.catalog.snps.tsv", intern = TRUE)
m3_rx_SNPs <- as.numeric(strsplit(m3_rx_SNPs, split = " ")[[1]][1])
stuff <- rbind(stuff, c("SNPs in catalog -m 3 after corrections module", m3_rx_SNPs))

# Number of SNPs filtered because of populations:
SNPs_in_VCF <- system("wc -l data/STACKS_processed/4_depth_optimization/m3/rxstacks_corrected/batch_1.vcf", intern = TRUE)
SNPs_in_VCF <- as.numeric(strsplit(SNPs_in_VCF, split = " ")[[1]][1]) - 11
filtered_out <- m3_rx_SNPs - SNPs_in_VCF
stuff <- rbind(stuff, c("SNPs filtered out w/populations module", filtered_out))

# Number of SNPs filtered out for coverage:
stuff <- rbind(stuff, c("SNPs filtered in -m 3 due to coverage", (SNPs_in_VCF - m3_cat_size)))

# Observed Heterozygosity (Ho) min
m3 <- "results/3_optimizing_depth/batch_1.sumstats_summary_tail.tsv"
m3_data <- read.table(m3, sep = "\t", stringsAsFactors = FALSE, comment.char ="", header = TRUE)
m3_data <- m3_data[-which(m3_data$X..Pop.ID == "HM"), ] # remove outgroup

min_Ho <- which(m3_data$Obs.Het == min(m3_data$Obs.Het)) 
stuff <- rbind(stuff, c("minimum observed Heterozygosity", m3_data$Obs.Het[min_Ho]))

# SD of min Ho
stuff <- rbind(stuff, c("sd of minimum Ho", m3_data$Var.2[min_Ho]))

# Max Ho:
max_Ho <- which(m3_data$Obs.Het == max(m3_data$Obs.Het))
stuff <- rbind(stuff, c("max Ho", m3_data$Obs.Het[max_Ho]))

# Max Ho SD:
stuff <- rbind(stuff, c("sd of maximum Ho", m3_data$Var.2[max_Ho]))

# Mean Hos:
stuff <- rbind(stuff, c("mean Ho across pops", mean(m3_data$Obs.Het)))

# SD of mean Hos:
stuff <- rbind(stuff, c("sd Ho across pops", sd(m3_data$Obs.Het)))

# Population with max Ho:
stuff <- rbind(stuff, c("population with max Ho", m3_data$X..Pop.ID[max_Ho]))

# Population with min Ho:
stuff <- rbind(stuff, c("population with min Ho", m3_data$X..Pop.ID[min_Ho]))

# Min He
min_He <- which(m3_data$Exp.Het == min(m3_data$Exp.Het)) 
stuff <- rbind(stuff, c("minimum observed Heterozygosity", m3_data$Exp.Het[min_He]))

# SD of min He
stuff <- rbind(stuff, c("sd of minimum Ho", m3_data$Var.4[min_He]))

# Max He:
max_He <- which(m3_data$Exp.Het == max(m3_data$Exp.Het))
stuff <- rbind(stuff, c("max He", m3_data$Exp.Het[max_He]))

# Max He SD:
stuff <- rbind(stuff, c("sd of maximum He", m3_data$Var.4[max_He]))

# Mean Hes:
stuff <- rbind(stuff, c("mean He across pops", mean(m3_data$Exp.Het)))

# SD of mean Hes:
stuff <- rbind(stuff, c("sd He across pops", sd(m3_data$Exp.Het)))

# Min Pi
min_pi <- which(m3_data$Pi == min(m3_data$Pi)) 
stuff <- rbind(stuff, c("minimum observed pi", m3_data$Pi[min_pi]))

# SD of min Pi
stuff <- rbind(stuff, c("sd of minimum pi", m3_data$Var.6[min_pi]))

# Max Pi:
max_pi <- which(m3_data$Pi == max(m3_data$Pi))
stuff <- rbind(stuff, c("max pi", m3_data$Exp.Het[max_pi]))

# Max Pi SD:
stuff <- rbind(stuff, c("sd of maximum pi", m3_data$Var.6[max_pi]))

# Mean Pis:
stuff <- rbind(stuff, c("mean pi across pops", mean(m3_data$Pi)))

# SD of mean Pis:
stuff <- rbind(stuff, c("sd pi across pops", sd(m3_data$Pi)))


# Mantel test P for Yangtze River over time:
mantelp <- read.table("results/3_optimizing_depth/table_mantel_test_p_values.txt", sep = "\t", header = FALSE, stringsAsFactors = FALSE)
stuff <- rbind(stuff, c("Mantel test P-value for Yangtze River over time", mantelp[1,2]))
stuff <- rbind(stuff, c("Mantel test P-value for spatial samples", mantelp[2,2]))



##### Write out table of stats:
write.table(stuff, "results/1_general_info/stats_for_paper.txt", sep = "\t", row.names = FALSE, quote = FALSE)

print("DONE!")